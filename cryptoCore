# Crypto Core - Keegan Bowen

############################
#      ALIAS SECTION       #
############################

# gpg alias section
# pass the key to gpgp and get detailed information
alias gpgp='gpg --list-packets'
# list out the keyring of the current user
alias gpgl='gpg --list-keys'

# openssl alias section
# populate the info interactively and generate a new rsa key
alias grsa='openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048'
# self signed cert
alias grsas='openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365'
# remove password from an rsa key
alias removekeypass='openssl rsa -in privateKey.pem -out newPrivateKey.pem'
# pass the certificate to checkcrt to get the info
alias checkcrt='openssl x509 -text -noout -in '
# generate md5 hashes for certificate.crt privateKey.key and CSR.csr
alias hashcheck='openssl x509 -noout -modulus -in certificate.crt | openssl md5; openssl rsa -noout -modulus -in privateKey.key | openssl md5; openssl req -noout -modulus -in CSR.csr | openssl md5'
# check on a pk12
alias checkpk12p='openssl pkcs12 -info -in'
# request a sign
alias requestsign='openssl req -newkey rsa:2048 -sha256 -nodes -out servercert.csr -outform PEM'

############################
#    PRACTICAL FUNCTIONS   #
############################


getpin () {
echo "enter site:";
read hashsite &&
openssl s_client -servername "$hashsite" -connect "$hashsite":443 | openssl x509 -pubkey -noout | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64;
}


############################
#    ADHOC BINARY XOR      #
############################

# adhoc-crypto on the disk
# for academic purposes

# Convert common decimals to binary.
# The int2bin function can only handle 20 character inputs at a time.
int2bin () {
    num="$1"
    bin=""
    padding=""
    base2=(0 1)
    while [ "$num" -gt 0 ]; do
        bin=${base2[$(($num % 2))]}$bin
        num=$(($num / 2))
    done
    if [ $((8 - (${#bin} % 8))) -ne 8 ]; then
        printf -v padding '%*s' $((8 - (${#bin} % 8))) ''
        padding=${padding// /0}
    fi
    echo $padding$bin
}

# Call tr program to remove whitespace of all kinds
# to prepare for bitwise XOR.
stripper () {
tr -d '\040\011\012\015'
}

# Convert binary to decimal. This thing needs work.
bin2dec () {
    echo $((2#$1))
}

# Return the seed length.
msglgth () {
SETMSGLGTH=$(cat ~/seeds/a.xor | wc -c)
}

# Bitwise XOR.
exor () {
bash ~/Scripts/xor.sh
}
# Repeat n times command.
repeat () {
    local i max
    max=$1; shift;
    for ((i=1; i <= max ; i++)); do
        eval "$@";
    done
}
# One-time-pad batch XOR.
otpbatch () {
for datasets in $(ls ~/seeds/*); do 
    cat $datasets | stripper > ~/seeds/b.xor; 
    exor > "$datasets".output; 
done 2> /dev/null &
}

# Same as otpbatch but with verbose output
reqbatch () {
for datasets in $(ls ~/seeds/*); do
echo "setting $datasets to b.xor";
cat $datasets | stripper > ~/seeds/b.xor;
echo "now b.xor is $(cat ~/seeds/b.xor)";
echo "XOR $datasets against a.xor - $(cat ~/seeds/a.xor)"
exor > "$datasets".output;
done 2> /dev/null 
}

# Run a validation check on the seed files.
libvalidate () {
for data in $(ls ~/seeds/*); do
    echo "$data"; 
    cat "$data" | wc -c; 
    echo "$data stripped"; 
    cat "$data" | stripper | wc -c; 
done
}

# Generate a medium sized library of binary digits for playing with.
libgen () { 
    for x in {1000..9999}; 
        do int2bin "$x" > "$x".xor ; 
    done
}
